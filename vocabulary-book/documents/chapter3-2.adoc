:toc: left
:source-highlighter: coderay
:experimental:

== Chapter 3-2 整理の方針

=== 機能の分解
一定の方針に従ってコードを整理していきます。
今回はレイヤーアーキテクチャを利用して、アプリケーションを組み立てることにします。
レイヤーアーキテクチャはアプリケーションを機能（責務）によってレイヤー（層）に分割して管理する方法です。

層の分割方法はいくつかありますが、今回はシンプルに３層に分割してみましょう。

==== レイヤー種類
====
プレゼンテーション::
プレゼンテーション層はユーザーとのやり取りを担当します。
ユーザーの入力を受け取ったり、ユーザーへ処理結果を表示する役目を持ちます。

ビジネスロジック::
ビジネスロジック層はアプリの中心です。
アプリの持つ機能は全てこの層に集約されます。

データアクセス::
データアクセス層はその名の通り、データの格納場所へのアクセスを担当します。
データ格納場所へのアクセスはデータアクセス層を介してのみアクセスすることで、アクセス経路を一元化します。
====

このセクションでは実装は行いませんが、一つ一つのレイヤーをクラスで表現するというわけです。

次に、これまで作ってきたアプリケーションを機能別に整理してみました。

==== 機能別に整理
====
. コマンドを受け取る
. コマンドを解釈する
. コマンドに応じて、振る舞いを決定する
. 単語を登録・削除・探す
. 結果を表示する
====

これらの機能を層に振り分けてみましょう。

.レイヤーと機能のマッピング
|===
|レイヤー/層|機能

.2+|プレゼンテーション
|1. コマンドを受け取る
|5. 結果を表示する

.2+|ビジネスロジック
|2. コマンドを解釈する
|3. コマンドに応じて、振る舞いを決定する

|データアクセス
|4. 単語を登録・削除・探す
|===

==== シーケンス図

図を詳しく見ていくと、気がつくかもしれません。
基本的にレイヤー/層をまたいだ呼び出しを行うことはできません。

依存するのは常に下位のレイヤー/層のみです（つまり``imports``に上位のレイヤーを設定してはいけません）
一つの方向への参照を守ることで、コードが複雑になっても破綻することはありません。

[plantuml]
----
@startuml
actor ユーザー
participant プレゼンテーション
participant ロジック
participant データアクセス
participant データ

ユーザー->プレゼンテーション: コマンド入力
プレゼンテーション->ロジック: コマンド実行
ロジック->ロジック: コマンドを解釈
ロジック->ロジック: 振る舞いを決定する
ロジック->データアクセス: データアクセス呼び出し
データアクセス->データ: 登録
データアクセス->データ: 削除
データアクセス->データ: 探す

データアクセス<-データ: 登録内容返却
ロジック<-データアクセス: 登録内容返却
プレゼンテーション<-ロジック: 翻訳語
プレゼンテーション<-ロジック: 登録・削除メッセージ
プレゼンテーション<-ロジック: コマンド失敗メッセージ
プレゼンテーション<-ロジック: 終了判定
ユーザー<-プレゼンテーション: 画面表示
ユーザー<-プレゼンテーション: 終了判定

@enduml
----

=== 次のセクションでは…

この方針に従って、まずはレイヤーのインターフェイスを設計します。

* link:chapter3-3.html[Chapter 3-3 インターフェイスの設計]

=== リンク

* link:chapter3-1.html[Chapter 3-1 コードを整理する]
* link:chapter3-2.html[Chapter 3-2 整理の方針]
* link:chapter3-3.html[Chapter 3-3 インターフェイスの設計]
* link:chapter3-4.html[Chapter 3-4 インターフェイスコーディング例]
* link:chapter3-5.html[Chapter 3-5 インターフェイスを実装する]
* link:chapter3-6.html[Chapter 3-6 コーディング例]
* link:chapter3-7.html[Chapter 3-7 テストの作成]
* link:chapter3-8.html[Chapter 3-8 テストコーディング例]
