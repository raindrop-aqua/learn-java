:toc: left
:icons: font
:source-highlighter: coderay
:experimental:

== Chapter 3-2 整理の方針

=== 機能の分解
一定の方針に従ってコードを整理していきます。
今回はレイヤーアーキテクチャを利用して、アプリケーションを組み立てることにします。
レイヤーアーキテクチャはアプリケーションを機能（責務）によってレイヤー（層）に分割して管理する方法です。

層の分割方法はいくつかありますが、今回はシンプルに３層に分割してみましょう。

==== レイヤー種類
====
プレゼンテーション::
プレゼンテーション層はユーザーとのやり取りを担当します。
ユーザーの入力を受け取ったり、ユーザーへ処理結果を表示する役目を持ちます。

ビジネスロジック::
ビジネスロジック層はアプリの中心です。
アプリの持つ機能は全てこの層に集約されます。

データアクセス::
データアクセス層はその名の通り、データの格納場所へのアクセスを担当します。
データ格納場所へのアクセスはデータアクセス層を介してのみアクセスすることで、アクセス経路を一元化します。
====

このセクションでは実装は行いませんが、一つ一つのレイヤーをクラスで表現するというわけです。

次に、これまで作ってきたアプリケーションを機能別に整理してみました。

==== 機能別に整理
====
. コマンドを受け取る
. コマンドを解釈する
. コマンドに応じて、振る舞いを決定する
. 単語を登録・削除・探す
. 結果を表示する
====

これらの機能を層に振り分けてみましょう。

.レイヤーと機能のマッピング
|===
|レイヤー/層|機能

.2+|プレゼンテーション
|1. コマンドを受け取る
|5. 結果を表示する

.2+|ビジネスロジック
|2. コマンドを解釈する
|3. コマンドに応じて、振る舞いを決定する

|データアクセス
|4. 単語を登録・削除・探す
|===

==== シーケンス図

図を詳しく見ていくと、気がつくかもしれません。
基本的にレイヤー/層をまたいだ呼び出しを行うことはできません。

依存するのは常に下位のレイヤー/層のみです（つまり``imports``に上位のレイヤーを設定してはいけません）
一つの方向への参照を守ることで、コードが複雑になっても破綻することはありません。

[plantuml]
----
@startuml
actor ユーザー
participant プレゼンテーション
participant ロジック
participant データアクセス
participant データ

ユーザー->プレゼンテーション: コマンド入力
プレゼンテーション->ロジック: コマンド実行
ロジック->ロジック: コマンドを解釈
ロジック->ロジック: 振る舞いを決定する
ロジック->データアクセス: データアクセス呼び出し
データアクセス->データ: 登録
データアクセス->データ: 削除
データアクセス->データ: 探す

データアクセス<-データ: 登録内容返却
ロジック<-データアクセス: 登録内容返却
プレゼンテーション<-ロジック: 翻訳語
プレゼンテーション<-ロジック: 登録・削除メッセージ
プレゼンテーション<-ロジック: コマンド失敗メッセージ
プレゼンテーション<-ロジック: 終了判定
ユーザー<-プレゼンテーション: 画面表示
ユーザー<-プレゼンテーション: 終了判定

@enduml
----

=== なぜコードを分割するのか？
[NOTE]
====
一つの関数の中にたくさんの機能を詰め込むこともできますが、保守のことを考えた場合、
適切にコードは分割したほうがいいです。

コードを分解するときのポイント::
一つ一つの関数を実行したときに、副作用がおこらないように作成するべきです（副作用を持たない関数は、関数の実施前後で状態が変わりません
+
関数を実施した結果、メンバ変数を変更する関数は状態を変更しています。メンバ変数の変更を伴わないようにするために、クラスメソッドにするのも一つの手です。
クラスメソッドはメンバ変数へのアクセスができないため、状態の変更を最小限に抑えることができます。
+
関数を何度実行しても動作が変わらないように冪等性（べきとうせい）を意識してコーディングを行いましょう。

テストを行いやすくするため::
適切に分割された関数は状態を変えないため、テストを行いやすい特性を持っています。
+
テストコードを記述していて、状態を意識しなければいけないことに気がついた場合、関数の見直しを検討しましょう。
====

=== 次のセクションでは…

この方針に従って、まずはレイヤーのインターフェイスを設計します。

* link:chapter3-3.html[Chapter 3-3 インターフェイスの設計]

=== リンク

* link:chapter3-1.html[Chapter 3-1 コードを整理する]
* link:chapter3-2.html[Chapter 3-2 整理の方針]
* link:chapter3-3.html[Chapter 3-3 インターフェイスの設計]
* link:chapter3-4.html[Chapter 3-4 インターフェイスコーディング例]
* link:chapter3-5.html[Chapter 3-5 インターフェイスを実装する]
* link:chapter3-6.html[Chapter 3-6 コーディング例]
* link:chapter3-7.html[Chapter 3-7 テストの作成]
* link:chapter3-8.html[Chapter 3-8 テストコーディング例]
